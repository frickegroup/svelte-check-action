import { get_pr_files, is_subdir } from './files';
import { get_diagnostics } from './diagnostic';
import { DiagnosticStore } from './store';
import { get_ctx, type CTX } from './ctx';
import * as core from '@actions/core';
import { render } from './render';

/**
 * Send a message to the current PR, taking into account
 * whether the last message can be edited instead.
 */
async function send(ctx: CTX, body: string) {
	const { data: comments } = await ctx.octokit.rest.issues.listComments({
		issue_number: ctx.pr_number,
		owner: ctx.owner,
		repo: ctx.repo,
	});

	const last_comment = comments
		.filter((comment) => comment.body?.startsWith('# Svelte Check Results'))
		.sort((a, b) => Date.parse(b.created_at) - Date.parse(a.created_at))
		.at(0);

	if (last_comment) {
		await ctx.octokit.rest.issues.updateComment({
			comment_id: last_comment.id,
			issue_number: ctx.pr_number,
			owner: ctx.owner,
			repo: ctx.repo,
			body,
		});
	} else {
		await ctx.octokit.rest.issues.createComment({
			issue_number: ctx.pr_number,
			owner: ctx.owner,
			repo: ctx.repo,
			body,
		});
	}
}

async function main() {
	const ctx = get_ctx();

	const changed_files = await get_pr_files(ctx);
	const diagnostics = new DiagnosticStore(ctx, changed_files);

	for (const root_path of ctx.config.diagnostic_paths) {
		const has_changed_files = changed_files
			? changed_files.some((pr_file) => is_subdir(root_path, pr_file))
			: true;

		console.log(`${has_changed_files ? 'checking' : 'skipped'} "${root_path}"`);

		if (has_changed_files) {
			for (const diagnostic of await get_diagnostics(root_path)) {
				diagnostics.add(diagnostic);
			}
		}
	}

	core.startGroup('Debug information');
	console.log({
		ctx: {
			...ctx,
			octokit: '(hidden)',
			token: '(hidden)',
		},
		diagnostics: {
			store: diagnostics.store,
			warning_count: diagnostics.warning_count,
			error_count: diagnostics.error_count,
			filtered_error_count: diagnostics.filtered_error_count,
			filtered_warning_count: diagnostics.filtered_warning_count,
		},
		changed_files,
	});
	core.endGroup();

	// Send the GitHub workflow annotations
	for (const [path, diags] of diagnostics.entries()) {
		for (const diagnostic of diags) {
			const report = diagnostic.type === 'error' ? core.error : core.warning;

			report(diagnostic.message, {
				title: 'svelte-check',
				file: path,
				startLine: diagnostic.start.line,
				endLine: diagnostic.end.line,
				startColumn: diagnostic.start.character,
				endColumn: diagnostic.end.character,
			});
		}
	}

	const markdown = await render(ctx, diagnostics);
	await send(ctx, markdown);

	const failed =
		(ctx.config.fail_on_error && diagnostics.filtered_error_count) ||
		(ctx.config.fail_on_warning && diagnostics.filtered_warning_count);

	if (failed) {
		function stringify(key: string, enabled: boolean, count: number) {
			return `\`${key}\` is ${enabled ? 'enabled' : 'disabled'} (${count} issue${count === 1 ? '' : 's'})`;
		}

		core.setFailed(
			`Failed with ${diagnostics.filtered_count} filtered issue${diagnostics.filtered_count === 1 ? '' : 's'} ` +
				`(${diagnostics.count} total). ` +
				`${stringify('failOnError', ctx.config.fail_on_error, diagnostics.filtered_error_count)} & ` +
				`${stringify('failOnWarning', ctx.config.fail_on_warning, diagnostics.filtered_warning_count)}. `,
		);
	}
}

main()
	.then(() => console.log('Finished'))
	.catch((error) => core.setFailed(error instanceof Error ? error.message : `${error}`));
